{"name":"Pinq","tagline":"PHP Integrated query - Extensible collection query/expression API for PHP","body":"PHP Integrated query\r\n====================\r\n[![Build status](https://api.travis-ci.org/TimeToogo/Pinq.png)](https://travis-ci.org/TimeToogo/Pinq)\r\n[![Code quality](https://scrutinizer-ci.com/g/TimeToogo/Pinq/badges/quality-score.png?s=ddce8f86d3192ab4ca1134aa98e17ab7340014f7)](https://scrutinizer-ci.com/g/TimeToogo/Pinq)\r\n\r\n\r\nWhat is Pinq?\r\n=============\r\nBased off the .NET's [Linq](http://msdn.microsoft.com/en-us/library/bb397926.aspx), Pinq unifies querying across [arrays/iterators](#pinq-examples) and [external data sources](#pinq-external-source), in a single readable and concise [fluent API](#pinq-api).\r\n\r\n<a name=\"pinq-api\"></a>Query and collection API\r\n===============================================\r\n\r\nITraversable\r\n============\r\n\r\nThe `ITraversable` interface represents a range of values that are able to be queried upon with the following methods:\r\n\r\n**Queries**\r\n - `Where` - Filters the values according to the supplied predicate\r\n - `OrderBy/OrderByAscending/OrderByDescending` - Orders the values according the supplied order direction\r\n - `ThenBy/ThenByAscending/ThenByDescending` - Subsequently orders the values according the supplied order direction\r\n - `Skip` - Skip the supplied amount of values\r\n - `Take` - Limits the amount of values by the supplied amount\r\n - `Slice` - Retrieve a slice of values according to the specified offset and amount\r\n - `IndexBy` - Index the values according to the supplied mapping function\r\n - `GroupBy` - Groups the values according the supplied mapping function\r\n - `Unique` - Only return unique values\r\n - `Select` - Map the values according to the supplied function\r\n - `SelectMany` - Map the values according to the supplied function and merge the results\r\n - `First` - Returns the first value or null if empty\r\n - `Last` - Returns the last value or null if empty\r\n - `Contains` - Returns if the supplied value is present in the values\r\n - `offsetGet` - Returns a value at the supplied index\r\n - `offsetExists` - Whether a value exists for the supplied index\r\n\r\n**Set/List Operations**\r\n - `Append` - All values present in either the original or supplied values\r\n - `WhereIn` - All values present in both the original and supplied values\r\n - `Except` - All values present in the original but not in the supplied values\r\n - `Union` - Unique values present in either the original or supplied values\r\n - `Intersect` - Unique values present in both the original and supplied values\r\n - `Difference` - Unique values present in the original but not in the supplied values\r\n - `offsetSet` - Sets a value to supplied index\r\n - `offsetUnset` - Removes any value at the supplied index\r\n\r\n**Aggregates**\r\n - `Count` - The amount of values\r\n - `Exists` - Whether there are any values\r\n - `Aggregate` - Aggregates the values according to the supplied\r\n - `Maximum` - The maximum value\r\n - `Minimum` - The minimum value\r\n - `Sum` - The sum of all the values\r\n - `Average` - The average of all the values\r\n - `All` - Whether all the values evaluate to true\r\n - `Any` - Whether any of the values evaluate to true\r\n - `Implode` - Concatenates the values seperated by the supplied delimiter\r\n\r\n**Other**\r\n - `AsArray` - The values as an array\r\n\r\nICollection\r\n===========\r\n\r\nThe `ICollection` interface represents a queryable range of values that are also mutable, they can be manipulated and altered using the additional methods:\r\n\r\n - `Apply` - Walks the values with the supplied function\r\n - `AddRange` - Adds a range of values to the collection\r\n - `RemoveRange` - Removes a range of values from the collection\r\n - `RemoveWhere` - Removes the values according to the supplied predicate function\r\n - `Clear` - Removes all the values from the collection.\r\n\r\n\r\n<a name=\"pinq-examples\"></a>Some query examples\r\n===============================================\r\n\r\nThe below examples shows the query functionality using the built-in `Traversable` class. This is an implementaion of `ITraversable` that uses iterators to perform the query in-memory.\r\n\r\n```php\r\nuse Pinq\\ITraversable, Pinq\\Traversable;\r\n\r\n//All Even values\r\n$Numbers = Traversable::From(range(1, 10))->Where(function ($I) { return $I % 2 === 0; });\r\n\r\n//Values multiplied by 10\r\n$Numbers = Traversable::From(range(1, 5))->Select(function ($I) { return $I * 10; });\r\n\r\n//Average string length\r\n$Strings = Traversable::From(['foo', 'bar', 'crocodile'])->Average('strlen');\r\n\r\n//Order by ascending first then by descending third charater\r\n$Strings = Traversable::From(['foo', 'bar', 'baz'])\r\n        ->OrderByAscending(function ($I) { return $I[0]; })\r\n        ->ThenByDescending(function ($I) { return $I[2]; });\r\n\r\n//A complex example\r\n$Data = Traversable::From(range(1,100))\r\n        ->Where(function ($I) { return $I % 2 === 0; }) //Only even values\r\n        ->OrderByDescending(function ($I) { return $I; }) //Order from largest to smallest\r\n        ->GroupBy(function ($I) { return $I % 7; }) //Put into seven groups\r\n        ->Where(function (ITraversable $I) { return $I->Count() % 2 === 0; }) //Only groups with an even amount of values\r\n        ->Select(function (ITraversable $Numbers) {\r\n            return [\r\n                'First' => $Numbers->First(),\r\n                'Average' => $Numbers->Average(),\r\n                'Count' => $Numbers->Count(),\r\n                'Numbers' => $Numbers->AsArray(),\r\n            ];\r\n        });\r\n```\r\n\r\nLimitations\r\n===========\r\n - Within the query, one should not use control structures such as `if, switch, goto, while, foreach,...`, these are not classified as valid query expressions and cannot be used with external data sources.\r\n\r\n<a name=\"pinq-external-source\"></a>Querying on external data sources\r\n====================================================================\r\nThe `IQueryable` and `IRepository` interfaces are respective to `ITraversable` and `ICollection`. But the data source for these is not limited to an array or iterator, they are able to use any implementation of `IQueryProvider`/`IRepositoryProvider` respectively, one could query a database, XML, DOM, CSV, the possibilities are endless.\r\n\r\nImplementing an IQueryProvider\r\n==============================\r\nIn this exercise to understand the `IQueryProvider` and how it is to be implemented, we will create a basic query provider for a constant array of numbers `[1,2,3,4,5,6,7,8,9,10]` (This is pointless as there is `Traversable` for a PHP array but this should help to illustrate the concept):\r\n\r\nThe goal of this will be making a query provider capable of executing:\r\n```php\r\n$MyQueryableArray\r\n        ->Where(function ($Number)  { return $Number > 5; })\r\n        ->Select(function ($Number)  { return $Number * 10; })\r\n        ->Sum();\r\n```\r\n\r\nTo implement a `IQueryProvider` one must understand the how the query will be represented, a query is represented in two parts:\r\n - **`IScope`** - This contains many `ISegment`, each segment represents one or more methods calls from the `IQueryable` implementation. For example the `->Where(...)` would become a `Filter` segment and the `->Select(...)` would becom a `Select` segment. \r\n - **`IRequest`** - This represents the actual data requested, in this case `->Sum()`  so a `Sum` request, but it could be the underlying values (`AsArray()`), another aggregate (`Count()`, ...) etc.\r\n\r\nThere is also the `FunctionExpressionTree`, functions in the query will be parsed into this class, this contains details of the parameters and an expression tree representing the body of the function.\r\n\r\n**Steps**\r\n\r\n - For the first step we need the a class that will evaluate the expression tree of a given function against the array of values, this will extend the `ExpressionVisitor` class to traverse the expression tree:\r\n\r\n```php\r\nuse \\Pinq\\Expressions as O;\r\nuse \\Pinq\\FunctionExpressionTree;\r\n\r\n/**\r\n * To keep it consice we will only implement the bare minimum needed to evaluate the requirements.\r\n * This is capable of evaluating a single binary operation involving > or *\r\n */\r\nclass ExpressionTreeEvaluator extends O\\ExpressionVisitor\r\n{\r\n    private $Array;\r\n    private $MappedReturnedValues;\r\n    \r\n    public function __construct(array $Array)\r\n    {\r\n        $this->Array = $Array;\r\n    }\r\n    \r\n    /**\r\n     * Nice static method to easily evaluate the return expression against the array\r\n     */\r\n    public static function EvaluateReturn(FunctionExpressionTree $ExpressionTree, array $Array) {\r\n        $Evaluator = new self($Array);\r\n        \r\n        $Evaluator->Walk($ExpressionTree->GetFirstResolvedReturnValueExpression());\r\n        \r\n        return $Evaluator->MappedReturnedValues;\r\n    }\r\n    \r\n    protected function VisitBinaryOperation(O\\BinaryOperationExpression $Expression)\r\n    {\r\n        //Ignore the left operand, assume it is the value parameter\r\n        \r\n        $RightExpression = $Expression->GetRightOperandExpression();\r\n        \r\n        if(!($RightExpression instanceof O\\ValueExpression)) {\r\n            throw new \\Exception('I need a constant value on the right side of the query expression');\r\n        }\r\n        \r\n        $RightValue = $RightExpression->GetValue();\r\n        \r\n        switch ($Expression->GetOperator()) {\r\n            case O\\Operators\\Binary::GreaterThan:\r\n                $this->MappedReturnedValues = array_map(function ($I) use ($RightValue) { return $I > $RightValue; }, $this->Array);\r\n                break;\r\n            \r\n            case O\\Operators\\Binary::Multiplication:\r\n                $this->MappedReturnedValues = array_map(function ($I) use ($RightValue) { return $I * $RightValue; }, $this->Array);\r\n                break;\r\n\r\n            default:\r\n                throw new \\Exception('I cannot do this operation: ' . $Expression->GetOperator());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n - For the second step we need the a class that will evaluate the query scope of the supplied array, this extends the `SegmentVisitor` and will evaluate the `->Where(...)->Select(...)` part of the query:\r\n\r\n```php\r\nuse \\Pinq\\Queries\\Segments;\r\n\r\n/**\r\n * This is also the bare minimum.\r\n * Evaluating only 'Where' and 'Select' and ignoring the rest\r\n */\r\nclass QueryScopeEvaluator extends Segments\\SegmentVisitor\r\n{\r\n    private $Array;\r\n    \r\n    public function __construct(array $Array)\r\n    {\r\n        $this->Array = $Array;\r\n    }\r\n    \r\n    public function GetScopedArray()\r\n    {\r\n        return $this->Array;\r\n    }\r\n    \r\n    public function VisitFilter(Segments\\Filter $Query)\r\n    {\r\n        $MappedResults = ExpressionTreeEvaluator::EvaluateReturn($Query->GetFunctionExpressionTree(), $this->Array);\r\n        \r\n        foreach($MappedResults as $Key => $Value) {\r\n            //Remove any values that returned false from the function\r\n            if(!$Value) {\r\n                unset($this->Array[$Key]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    public function VisitSelect(Segments\\Select $Query)\r\n    {\r\n        $MappedResults = ExpressionTreeEvaluator::EvaluateReturn($Query->GetFunctionExpressionTree(), $this->Array);\r\n        \r\n        //Set the array to the projections from the function\r\n        $this->Array = $MappedResults;\r\n    }\r\n}\r\n````\r\n\r\n - Now to evaluate the `->Sum()` aggregate value, extending the `RequestVisitor` class, this is responsible for evaluating all the aggregates and retrieving the values:\r\n\r\n```php\r\n\r\nuse \\Pinq\\Queries\\Requests;\r\nuse \\Pinq\\FunctionExpressionTree;\r\n\r\n/**\r\n * This is also the bare minimum, evaluating only 'Sum'\r\n */\r\nclass RequestEvaluator extends Requests\\RequestVisitor\r\n{\r\n    private $Array;\r\n    \r\n    public function __construct(array $Array)\r\n    {\r\n        $this->Array = $Array;\r\n    }\r\n    \r\n    public function VisitSum(Requests\\Sum $Request)\r\n    {\r\n        if(count($this->Array) === 0) {\r\n            return null;\r\n        }\r\n        \r\n        //BONUS: if average was called with a projection function we can evaluate that to\r\n        $ProjectedValues = $this->EvaluateProjection($Request);\r\n        \r\n        $Sum = 0;\r\n        foreach($ProjectedValues as $Value) {\r\n            $Sum += $Value;\r\n        }\r\n        \r\n        return $Sum;\r\n    }\r\n    \r\n    private function EvaluateProjection(Requests\\ProjectionRequest $Request) \r\n    {\r\n        if($Request->HasFunctionExpressionTree()) {\r\n            return ExpressionTreeEvaluator::EvaluateReturn($Request->GetFunctionExpressionTree(), $this->Array);\r\n        }\r\n        else {\r\n            return $this->Array;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n- Bringing it all together and implementing the `IQueryProvider` by extending `QueryProvider` which implements basic boiler plate for the query provider:\r\n\r\n```php\r\nuse \\Pinq\\Providers;\r\nuse \\Pinq\\Queries;\r\n\r\nclass ArrayQueryProvider extends Providers\\QueryProvider \r\n{\r\n    private $Array = [1,2,3,4,6,7,8,9,10];\r\n    \r\n    protected function LoadRequestEvaluatorVisitor(Queries\\IScope $Scope)\r\n    {\r\n        //Evaluate the query scope: ->Where(...)->Select(...)\r\n        $ScopedEvaluator = new QueryScopeEvaluator($this->Array);\r\n        $ScopedEvaluator->Walk($Scope);\r\n        $ScopedArray = $ScopedEvaluator->GetScopedArray();\r\n        \r\n        //Return the request evaluator, it will be called and evaluate the ->Sum() query\r\n        return new RequestEvaluator($ScopedArray);\r\n    }\r\n}\r\n```\r\n\r\n- If we wanted to we could wrap this in a nice subclass of `Queryable` and automatically pass the appropriate query provider:\r\n\r\n```php\r\nclass ArrayQueryable extends \\Pinq\\Queryable\r\n{\r\n    public function __construct()\r\n    {\r\n        parent::__construct(new ArrayQueryProvider());\r\n    }\r\n}\r\n```\r\n\r\nFinally, we can see the action:\r\n\r\n```php\r\n$MyQueryableArray = new ArrayQueryable();\r\n\r\necho $MyQueryableArray\r\n        ->Where(function ($Number)  { return $Number > 5; })\r\n        ->Select(function ($Number)  { return $Number * 10; })\r\n        ->Sum();\r\n//Echos: 400\r\n```\r\n\r\nThis is an extremely basic, useless and naive implementation of the query provider, but nevertheless it does exactly as we wanted. \r\n\r\nHopefully, this helps to illustrate the capabilities of Pinq and its built-in expression language. Its ability and to provide a seamless integration with PHP and external data sources.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}